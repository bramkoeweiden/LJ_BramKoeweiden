---
title: "Week 4"
author: "Bram"
date: "2025-09-26"
output: html_document
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

------------------------------------------------------------------------

```{r}



library (igraph)

require(igraph)
g <- make_graph("Zachary")
plot(g)

gmat <- as_adjacency_matrix(g, type = "both", sparse = FALSE)
gmat

# number of nodes
vcount(g)
# number of edges
ecount(g)

igraph::triad.census(g)


library (sna)

# be aware that directed graphs are considered as undirected. but g is undirected.
igraph::transitivity(g, type = c("localundirected"), isolates = c("NaN", "zero"))

igraph::betweenness(g, directed = FALSE)

# I will use sna because it shows the names of the triads as well.
sna::triad.census(gmat)


igraph::transitivity(g, type = "global")
sna::gtrans(gmat)

triad_g <- data.frame(sna::triad.census(gmat))

transitivity_g <- (3 * triad_g$X300)/(triad_g$X201 + 3 * triad_g$X300)
transitivity_g

# changing V
V(g)$size = igraph::betweenness(g, normalized = T, directed = FALSE) * 60 + 10  #after some trial and error
plot(g, mode = "undirected")



?igraph
?layout

#change layout for less overlap
set.seed(2345)
set.seed(42)
l <- layout_with_mds(g)  #https://igraph.org/r/doc/layout_with_mds.html
plot(g, layout = l)


l  #let us take a look at the coordinates
l[1, 1] <- 4
l[34, 1] <- -3.5
plot(g, layout = l)
```

```{r, eval= FALSE}
rm(list = ls())

fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave <- function(x, file = NULL, location = "./data/processed/") {
    ifelse(!dir.exists("data"), dir.create("data"), FALSE)
    ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, ".rda", sep = "")
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload <- function(filename) {
    load(filename)
    get(ls()[ls() != "filename"])
}

fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}


#install.packages("tidyverse")
#install.packages("scholar") 
#install.packages("openalexR")
#install.packages("rvest") 
#install.packages("jsonlite")
#install.packages("kableExtra")
#install.packages ("httr")
#install.packages ("xml2") 
#install.packages ("rvest") 
#install.packages ("reshape2") 

library(tidyverse)
library(scholar) 
library(openalexR)
library(rvest) 
library(jsonlite)
library(kableExtra)
library (httr) 
library (xml2) 
library (rvest) 
library (reshape2) 
library(scholar)
library (ids)
library (stringr)
library (stringi)

# Using openalexR (less information)
df_names <- fload('/Users/bramkoeweiden/Documents/Social Networks/LJ_BramKoeweiden/Data/Processed/20230620df_gender_jt.rda')
view (df_names)

#empty list
df_names <- fload('/Users/bramkoeweiden/Documents/Social Networks/LJ_BramKoeweiden/Data/Processed/20230620df_gender_jt.rda')
view (df)

co_authorships <- list()

for (author_name in df_names$name) {

df <- oa_fetch(entity = "author", search = author_name)
fshowdf(df)

df_papers <- oa_fetch(entity = "works", author.id = df$id)

# Unnest the df's in authorships row of df_papers dataset

df_papers2 <- df_papers %>%
  unnest_longer (authorships) %>%
  unnest_wider (authorships, names_sep="_")

str (df_papers2$authorships_display_name)

# Making new df which counts collaborations with JT

co_authors <- df_papers2 %>%
count(authorships_display_name)

co_authorships[[author_name]] <- co_authors



}




```

```{r}
# Part 2 (nomination network)

## Getting started

rm(list=ls())


fpackage.check <- function(packages) {
  lapply(packages, FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  })
}

fsave <- function(x, file=NULL, location="./data/processed/") {
  ifelse(!dir.exists("data"), dir.create("data"), FALSE)
  ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
  if (is.null(file)) file= deparse(substitute(x))
  datename <- substr(gsub("[:-]", "", Sys.time()), 1,8)  
  totalname <- paste(location, file, "_", datename, ".rda", sep="")
  save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload <- function(filename) {
  load(filename)
  get(ls()[ls() != "filename"])
}

fshowdf <-  function(x, ...) {
  knitr::kable(x, digits=2, "html", ...) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
  kableExtra::scroll_box(width="100%", height= "300px")
} 

packages <- c("tidyverse", "scholar", "openalexR", "rvest", "jsonlite")
fpackage.check(packages)
```


## input data
```{r}
#Please download these files:  

xfun::embed_file("./data/processed/scholars_20240924.rda")  

#Save file in correct directory: './data/processed'. 
scholars <- fload("./data/processed/scholars_20240924.rda")

```



## make a nomination network

I will first show how to do this step by step and then make your life easier by making a function.



```{r}
### step 1: select scholars 
#(sociology, RU)
demographics <- do.call(rbind.data.frame, scholars$demographics)
demographics <- demographics %>%  mutate(
  Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), ""),
  Universiteit2.22 = replace(Universiteit2.22, is.na(Universiteit2.22), ""),
  Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24), ""),
  Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), ""),
  discipline.22 = replace(discipline.22, is.na(discipline.22), ""),
  discipline.24 = replace(discipline.24, is.na(discipline.24), "")
  )

sample <- which((demographics$Universiteit1.22 == "RU" | demographics$Universiteit2.22 == "RU" | demographics$Universiteit1.24 == "RU" | demographics$Universiteit2.24 == "RU") & (demographics$discipline.22 == "sociology" | demographics$discipline.24 == "sociology")) 

demographics_soc <- demographics[sample, ]
scholars_sel <- lapply(scholars, '[', sample)


### step 2: construct the empty adjacency matrix
# syntax for weighted adjacency matrix

ids_w <- demographics_soc$au_id
wave2_w <- wave1_w <- matrix(0, nrow=length(ids_w), ncol=length(ids_w), dimnames = list(ids_w, ids_w))

### step 3: filter works
#Included all works
works <- scholars_sel$work

works_id <- unlist(lapply(works, function(l) l$id))
works_author <- unlist(lapply(works, function(l) l$author), recursive = FALSE)
works_year <- unlist(lapply(works, function(l) l$publication_year), recursive = FALSE)

df_works <- tibble(works_id, works_author, works_year)

dups <- which(duplicated(works_id))
#why are there some many papers of Batenburg duplicates

df_works <- df_works[-dups,]
df_works_w2 <- df_works#[df_works$works_year>2019,]

#Limiet 2019 eraf halen


### step 4: fill the matrix
#Each collaboration is counted which means weight is added
#first to others
for (i in 1:nrow(df_works_w2)) {
  ego <- df_works_w2$works_author[i][[1]]$au_id[1]
  alters <- df_works_w2$works_author[i][[1]]$au_id[-1]

  if (sum(ids_w %in% ego) > 0 & sum(ids_w %in% alters) > 0) {
    wave2_w[which(ids_w %in% ego), which(ids_w %in% alters)] <- wave2_w[which(ids_w %in% ego), which(ids_w %in% alters)] + 1
  }
}

#repliceer laatste regel voor volgend blok

#last to others
for (i in 1:nrow(df_works_w2)) {
  ego <- rev(df_works_w2$works_author[i][[1]]$au_id)[1]
  alters <- rev(df_works_w2$works_author[i][[1]]$au_id)[-1]

  if (sum(ids_w %in% ego) > 0 & sum(ids_w %in% alters) > 0) {
    wave2_w[which(ids_w %in% ego), which(ids_w %in% alters)] <-  wave2_w[which(ids_w %in% ego), which(ids_w %in% alters)] +1
  }
}

#undirected
for (i in 1:nrow(df_works_w2)) {
  egos <- df_works_w2$works_author[i][[1]]$au_id
 
  if (sum(ids_w %in% egos) > 0 ) {
    wave2_w[which(ids_w %in% egos), which(ids_w %in% egos)] <- wave2_w[which(ids_w %in% egos), which(ids_w %in% egos)] +1
  }
}


```

### step 2: construct the empty adjacency matrix

For unweighted adjacency matrix

```{r, eval = TRUE}
ids <- demographics_soc$au_id
wave2 <- wave1 <- matrix(0, nrow=length(ids), ncol=length(ids), dimnames = list(ids, ids))
```

### step 3: filter works

```{r, eval = TRUE}
works <- scholars_sel$work

works_id <- unlist(lapply(works, function(l) l$id))
works_author <- unlist(lapply(works, function(l) l$author), recursive = FALSE)
works_year <- unlist(lapply(works, function(l) l$publication_year), recursive = FALSE)

df_works <- tibble(works_id, works_author, works_year)

dups <- which(duplicated(works_id))
#why are there some many papers of Batenburg duplicates

df_works <- df_works[-dups,]
df_works_w2 <- df_works#[df_works$works_year>2019,]

#Limiet 2019 eraf halen

```

### step 4: fill the matrix

```{r, eval = TRUE}
#first to others
for (i in 1:nrow(df_works_w2)) {
  ego <- df_works_w2$works_author[i][[1]]$au_id[1]
  alters <- df_works_w2$works_author[i][[1]]$au_id[-1]

  if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
    wave2[which(ids %in% ego), which(ids %in% alters)] <- wave2[which(ids %in% ego), which(ids %in% alters)] + 1
  }
}

#repliceer laatste regel voor volgend blok

#last to others
for (i in 1:nrow(df_works_w2)) {
  ego <- rev(df_works_w2$works_author[i][[1]]$au_id)[1]
  alters <- rev(df_works_w2$works_author[i][[1]]$au_id)[-1]

  if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
    wave2[which(ids %in% ego), which(ids %in% alters)] <-  wave2[which(ids %in% ego), which(ids %in% alters)] +1
  }
}

#undirected
for (i in 1:nrow(df_works_w2)) {
  egos <- df_works_w2$works_author[i][[1]]$au_id
 
  if (sum(ids %in% egos) > 0 ) {
    wave2[which(ids %in% egos), which(ids %in% egos)] <- wave2[which(ids %in% egos), which(ids %in% egos)] +1
  }
}
```

```{r, eval = FALSE}

#Original step 4 Jochem

for (i in 1:nrow(df_works_w2)) {
  ego <- df_works_w2$works_author[i][[1]]$au_id[1]
  alters <- df_works_w2$works_author[i][[1]]$au_id[-1]

  if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
    wave2[which(ids %in% ego), which(ids %in% alters)] <- 1
  }
}

#repliceer laatste regel voor volgend blok

#last to others
for (i in 1:nrow(df_works_w2)) {
  ego <- rev(df_works_w2$works_author[i][[1]]$au_id)[1]
  alters <- rev(df_works_w2$works_author[i][[1]]$au_id)[-1]

  if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
    wave2[which(ids %in% ego), which(ids %in% alters)] <-  1
  }
}

#undirected
for (i in 1:nrow(df_works_w2)) {
  egos <- df_works_w2$works_author[i][[1]]$au_id
 
  if (sum(ids %in% egos) > 0 ) {
    wave2[which(ids %in% egos), which(ids %in% egos)] <- 1
  }
}

```

## function for collaboration networks

About the parameters:

-   `data`: our scholars file\
-   `university`: Character vector with names of universities. We have several universities in the Netherlands. See above for relevant names.\
-   `discipline`: Character vector, either *sociology* or *political science* or both.\
-   `waves`: a list of numeric vectors with start and end year of wave.\
-   `type`:
    -   `"first"`: directed: first author sending to others\
    -   `"last"`: directed: last author sending to others\
    -   `"all"`: undirected: ties between all authors

Output: - a list\
- `$nets`: array of nomination networks.\
- `$data`: sample of data (scholars)

```{r, eval= FALSE}
fcolnet <- function(data = scholars, university = "RU", discipline = "sociology", waves = list(c(2015, 2018), c(2019, 2023)), type = c("first")) {
  
  
  # step 1
  demographics <- do.call(rbind.data.frame, data$demographics)
  demographics <- demographics %>% mutate(
    Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), ""),
    Universiteit2.22 = replace(Universiteit2.22, is.na(Universiteit2.22), ""),
    Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24), ""),
    Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), ""),
    discipline.22 = replace(discipline.22, is.na(discipline.22), ""),
    discipline.24 = replace(discipline.24, is.na(discipline.24), "")
  )

  sample <- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in% university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in% university) & (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

  demographics_soc <- demographics[sample, ]
  scholars_sel <- lapply(scholars, "[", sample)

  # step 2
  ids <- demographics_soc$au_id
  nwaves <- length(waves)
  nets <- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids, ids))
  dimnames(nets)

  # step 3
  df_works <- tibble(
    works_id = unlist(lapply(scholars_sel$work, function(l) l$id)),
    works_author = unlist(lapply(scholars_sel$work, function(l) l$author), recursive = FALSE),
    works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year), recursive = FALSE)
  )

  df_works <- df_works[!duplicated(df_works), ]

  # step 4
  if (type == "first") {
    for (j in 1:nwaves) {
      df_works_w <- df_works[df_works$works_year>=waves[[j]][1] & df_works$works_year<=waves[[j]][2],]
      for (i in 1:nrow(df_works_w)) {
        ego <- df_works_w$works_author[i][[1]]$au_id[1]
        alters <- df_works_w$works_author[i][[1]]$au_id[-1]
        if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
          nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
        }
      }
    }
  }

  if (type == "last") {
    for (j in 1:nwaves) {
      df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2], ]
      for (i in 1:nrow(df_works_w)) {
        ego <- rev(df_works_w$works_author[i][[1]]$au_id)[1]
        alters <- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
        if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
          nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
        }
      }
    }
  }

  if (type == "all") {
    for (j in 1:nwaves) {
      df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2], ]
      for (i in 1:nrow(df_works_w)) {
        egos <- df_works_w$works_author[i][[1]]$au_id
        if (sum(ids %in% egos) > 0) {
          nets[j, which(ids %in% egos), which(ids %in% egos)] <- 1
        }
      }
    }
  }
  output <- list()
  output$data <- scholars_sel
  output$nets <- nets
  return(output)
}

```

```{r, eval=FALSE}
#Variables

#easiest way to compute redundancy is by using the constraints command from Igraph.
#This prints the sum of redundant ties an actor has.

degree(test_w2)



betweenness(test_w2)

constraint(test_w2)

constraint(test_w2_w)



#df_works_author <- df_works_w2 %>%
#  unnest_longer (works_author) %>%
#  unnest_wider (works_author, names_sep="_")

#view (df_works_author)

#str (df_works_author$works_author_au_display_name)

# Making new df which counts collaborations

#co_authors <- df_works_author %>%
#count(works_author_au_display_name)

#view (co_authors)








```

----

# Visualise as example

```{r}
test_w2 <- igraph::graph_from_adjacency_matrix(
  wave2,
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  #add.colnames = NULL,
  #add.rownames = NULL
)

test_w2_w <- igraph::graph_from_adjacency_matrix(
  wave2_w,
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  #add.colnames = NULL,
  #add.rownames = NULL
)

plot(test_w2,
  vertex.label = NA,
  edge.width = 0.1,
  edge.arrow.size =0.1)

# changing V
# V(test_w2)$size = betweenness(test_w2, directed = FALSE, normalized = T) * 60 + 10  #after some trial and error


set.seed(2345)
l <- layout_with_mds(test_w2)  #https://igraph.org/r/doc/layout_with_mds.html

plot(test_w2, mode = "undirected", 
     vertex.label = NA,
     edge.width = 0.2,
     edge.arrow.size =0.2,
     layout = l)
```

----
#Visualizing to show the role of constraints

```{r}



V(test_w2)$size = constraint(test_w2) * -25 + 30  #after some trial and error


set.seed(2345)

#Constraint cannot be computed for unconnected so subgraph without unconnected nodes is needed.

comp <- igraph::components(test_w2)
g_con <- induced_subgraph(test_w2, which(comp$membership == which.max(comp$csize)))
l <- layout_with_mds(g_con)

plot(g_con,
     layout = l,
     vertex.label = NA,
     edge.width = 0.2,
     edge.arrow.size = 0.2,
     vertex.size = V(g_con)$size)


```

----
#Linking datasets, from tutorial

```{r, eval = FALSE}
test <- fcolnet(data = scholars, 
                university = c("RU", "UvT"), 
                discipline = c("sociology", "political science"), 
                waves = list(c(2015, 2018), c(2019, 2023)), 
                type = c("all"))

test_w2 <- igraph::graph_from_adjacency_matrix(
  test$nets[2,,], #now, I take the second wave
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL
)

#Let us find ego characteristics. 
#first fish out the data
df <- test$data

#same complicated structure as 'scholars' thus first make a dataframe from the list in which all info was saved. 
df_ego <- do.call(rbind.data.frame, df$demographics)

#DO NOT MESS UP THE ORDER! THUS IF YOU JOIN THIS DATA WITH YOUR OWN DATA CHECK THAT ORDER REMAINED THE SAME!! 

plot(test_w2,
  vertex.color = ifelse(df_ego$discipline.24 == "sociology", "red", "blue"), #now, I can use actor attributes for plotting. 
  vertex.label = NA,
  edge.width = 0.2,
  edge.arrow.size =0.2)


```


[@ling2025]
